[{"categories":["fp"],"content":"承接上文结论，简单 OOP 范式下数据结构的扩展成本比较低下，而 FP 范式下算子的扩展成本 比较低下，在解决代码复杂度上是没有好哒方法，但是代码组织结构上还是有优化的空间。 这 2 种范式都有自己的方法来解决双向扩展所带来的代码分散问题。 ","date":"2021-11-23","objectID":"/posts/fp_vs_oop_2/:0:0","tags":["scala"],"title":"OOP 和 FP 在架构弹性的比较-2","uri":"/posts/fp_vs_oop_2/"},{"categories":["fp"],"content":"OOP(Visitor Pattern) 是时候操起设计模式大法了，23 种扫了一眼，访问者模式看起来在这儿挺能打的。那么撸起 袖子改起来，首先我们来看上回的代码。 trait Expr { def eval: Double def prettyPrint: String } case class Number(value: Double) extends Expr { override def eval = value override def print = value.toString } case class Add(a: Expr, b: Expr) extends Expr { override def eval = a.eval + b.eval override def print = s”(${a.print} + ${b.print})” } case class Neg(a: Expr) extends Expr { override def eval = — a.eval override def print = s”-${a.print}” } 核心就是把数据 trait Expr { def accept(visitor: IExpresstionEvalutaion): Double = visitor.visit(this) def accept(visitor: IExpresstionPrettyPrint): Void = visitor.visit(this) } case class Number(value: Double) extends Expr case class Add(a: Expr, b: Expr) extends Expr case class Neg(a: Expr) extends Expr object IExpresstionEvalutaion { def visit( number : Number) = number.value; def visit( number : Add) = eval(number.a) + eval(number.b) def visit( number : Nug) = eval(number.a) } object IExpresstionPrettyPrint { def visit( number : Number) = number.toString; def visit( number : Add) = s\"${visit(number.a)}+ ${visit(number.b)}\" def visit( number : Nug) = s\"-${(number.a)}\"\" } 之后无论扩展数据结构还是算子都收敛在一个文件内 ","date":"2021-11-23","objectID":"/posts/fp_vs_oop_2/:1:0","tags":["scala"],"title":"OOP 和 FP 在架构弹性的比较-2","uri":"/posts/fp_vs_oop_2/"},{"categories":["fp"],"content":"FP(type class) 这是朴素的 fp trait Expr case class Number(value: Double) extends Expr case class Add(a: Expr, b: Expr) extends Expr case class Neg(a: Expr) extends Expr def evaluate(expression: Expr): Double = expression match { case Number(a) =\u003e a case Add(a, b) =\u003e evaluate(a) + evaluate(b) case Neg(a) =\u003e — evaluate(a) } def print(expression: Expr): String = expression match { case Number(a) =\u003e a.toString case Add(a, b) =\u003e s”(${print(a)} + ${print(b)})” case Neg(a) =\u003e s”-${print(a)}” } typeclass 是一种 ad-hot polymorphism 技术，可以对任意类型进行方法的扩张，源自于 Haskell，在 scala 中可以利用隐式转换实现。 @typeclass trait Eval[A] { def eval(a : A): Double } @typeclass trait PrettyPrint[A]{ def prettyPrint(a : A): String } trait Expr case class Number(value: Double) extends Expr case class Add(a: Expr, b: Expr) extends Expr case class Neg(a: Expr) extends Expr implicit val EvalNumberInstance = new Eval[Number]{ override def eval(a : Number) = a.value } implicit val EvalAddInstance = new Eval[Add]{ override def eval(x : Add) = x.a.eval + x.b.eval } implicit val EvalNegInstance = new Eval[Neg]{ override def eval(x : Number) = - e.eval } implicit val PrettyPrintNumberInstance = new PrettyPrint[Number]{ override def prettyprint(a : Number) = a.toString } implicit val PrettyPrintAddInstance = new PrettyPrint[Add]{ override def prettyprint(x : Add) = s\"${x.a.prettyprint}+ ${x.b.prettyprint}\" } implicit val PrettyPrintNegInstance = new PrettyPrint[Neg]{ override def prettyprint(x : Number) = s\"- ${e.prettyprint}\" } ","date":"2021-11-23","objectID":"/posts/fp_vs_oop_2/:2:0","tags":["scala"],"title":"OOP 和 FP 在架构弹性的比较-2","uri":"/posts/fp_vs_oop_2/"},{"categories":["fp"],"content":"对于一个互联网公司的程序，代码的范式是很重要的，好的范式可以让你面对产品经理的指 示的时候痛苦感会降低， 这个时候架构就非常重要了。那么我将以 scala 为例，支持多范式 的语言不多，scala 是各种范式都能 hold 比较好的。展示一下 FP 和 OOP 的优缺点。 我们对架构先提出几点要求 拓展起来不会影响现有代码的清晰度 拓展起来的改动比较少 代码简单易测 假如有一天产品告诉你，来我们搞个计算器吧。第一期要实现加法和减法。那么你考虑的就 是这个 (2 +3 ) + 4 用 scala 程序表示起来, 就是要求值下面这个东西。 val expression = Add(Add(Number(2), Number(3)), Number(4)) ","date":"2021-11-22","objectID":"/posts/fp_vs_oop_1/:0:0","tags":["scala"],"title":"OOP 和 FP 在架构弹性的比较-1","uri":"/posts/fp_vs_oop_1/"},{"categories":["fp"],"content":"Round One ","date":"2021-11-22","objectID":"/posts/fp_vs_oop_1/:1:0","tags":["scala"],"title":"OOP 和 FP 在架构弹性的比较-1","uri":"/posts/fp_vs_oop_1/"},{"categories":["fp"],"content":"OOP 首先来了一个 OOP 程序员,拿起 IDE，三军未动粮草先行, 先来个接口爽一下。 trait Expr { def eval: Double } emm，不错，之后在快速继承一遍 case class Number(value: Double) extends Expr { override def eval = value } case class Add(a: Expr, b: Expr) extends Expr { override def eval = a.eval + b.eval } 下面是见证奇迹的时刻 expression.eval //res0: Double = 9.0 完美! ","date":"2021-11-22","objectID":"/posts/fp_vs_oop_1/:1:1","tags":["scala"],"title":"OOP 和 FP 在架构弹性的比较-1","uri":"/posts/fp_vs_oop_1/"},{"categories":["fp"],"content":"FP 接着来了一个 FP 程序员，嘴里念叨着 Functional core imperative shell, 首先把数据结构 和计算拆开来了 trait Expr case class Number(value: Double) extends Expr case class Add(a: Expr, b: Expr) extends Expr emm，纯数据结构清爽 def evaluate(expression: Expr): Double = expression match { case Number(a) =\u003e a case Add(a, b) =\u003e evaluate(a) + evaluate(b) } emm, 纯计算，清爽 下面是见证奇迹的时刻 evaluate(expression) //res0: Double = 9.0 完美! ","date":"2021-11-22","objectID":"/posts/fp_vs_oop_1/:1:2","tags":["scala"],"title":"OOP 和 FP 在架构弹性的比较-1","uri":"/posts/fp_vs_oop_1/"},{"categories":["fp"],"content":"Round 2 这个时候产品说了，这个计算器有点丑啊，能不能打印好看点 ","date":"2021-11-22","objectID":"/posts/fp_vs_oop_1/:2:0","tags":["scala"],"title":"OOP 和 FP 在架构弹性的比较-1","uri":"/posts/fp_vs_oop_1/"},{"categories":["fp"],"content":"OOP OOP 程序员熟练的修改了接口（改动+1） trait Expr { def eval: Double def prettyPrint: String } 然后（改动+1 + 1） = 3 处 case class Number(value: Double) extends Expr { override def eval = value override def print = value.toString } case class Add(a: Expr, b: Expr) extends Expr { override def eval = a.eval + b.eval override def print = s”(${a.print} + ${b.print})” } ","date":"2021-11-22","objectID":"/posts/fp_vs_oop_1/:2:1","tags":["scala"],"title":"OOP 和 FP 在架构弹性的比较-1","uri":"/posts/fp_vs_oop_1/"},{"categories":["fp"],"content":"FP 这就是加个方法的事儿（改动 +1) = 1 处 def print(expression: Expr): String = expression match { case Number(a) =\u003e a.toString case Add(a, b) =\u003e s”(${print(a)} + ${print(b)})” } ","date":"2021-11-22","objectID":"/posts/fp_vs_oop_1/:2:2","tags":["scala"],"title":"OOP 和 FP 在架构弹性的比较-1","uri":"/posts/fp_vs_oop_1/"},{"categories":["fp"],"content":"Round 3 产品又说了，只有加法不够呀，我们还需要个减法 ","date":"2021-11-22","objectID":"/posts/fp_vs_oop_1/:3:0","tags":["scala"],"title":"OOP 和 FP 在架构弹性的比较-1","uri":"/posts/fp_vs_oop_1/"},{"categories":["fp"],"content":"OOP 就是再实现一次接口呗（改动 +1) case class Neg(a: Expr) extends Expr { override def eval = — a.eval override def print = s”-${a.print}” } ","date":"2021-11-22","objectID":"/posts/fp_vs_oop_1/:3:1","tags":["scala"],"title":"OOP 和 FP 在架构弹性的比较-1","uri":"/posts/fp_vs_oop_1/"},{"categories":["fp"],"content":"FP 首先要拓展一个数据结构 case class Neg(a: Expr) extends Expr 然后所有的函数都要随之改动 def evaluate(expression: Expr): Double = expression match { case Number(a) =\u003e a case Add(a, b) =\u003e evaluate(a) + evaluate(b) case Neg(a) =\u003e — evaluate(a) } def print(expression: Expr): String = expression match { case Number(a) =\u003e a.toString case Add(a, b) =\u003e s”(${print(a)} + ${print(b)})” case Neg(a) =\u003e s”-${print(a)}” } ","date":"2021-11-22","objectID":"/posts/fp_vs_oop_1/:3:2","tags":["scala"],"title":"OOP 和 FP 在架构弹性的比较-1","uri":"/posts/fp_vs_oop_1/"},{"categories":["fp"],"content":"结论 没有银弹，OOP 范式下数据结构的扩展成本比较低，FP 范式下算子的扩展成本比较低。 ","date":"2021-11-22","objectID":"/posts/fp_vs_oop_1/:4:0","tags":["scala"],"title":"OOP 和 FP 在架构弹性的比较-1","uri":"/posts/fp_vs_oop_1/"},{"categories":["fsdf"],"content":"This post has no date. Export this second post only by bringing point here and doing M-x org-hugo-export-wim-to-md. ","date":"2021-11-22","objectID":"/posts/post-2/:0:0","tags":["ATTACH"],"title":"Post 2","uri":"/posts/post-2/"},{"categories":["fsdf"],"content":"This is some text before the first heading of this post. ","date":"2017-07-15","objectID":"/posts/image-links/:0:0","tags":["image"],"title":"Image links","uri":"/posts/image-links/"},{"categories":["fsdf"],"content":"sdkfjdkalsf dsafdsfdklsfl dsfas fasdfas fsdaf ","date":"2017-07-15","objectID":"/posts/image-links/:1:0","tags":["image"],"title":"Image links","uri":"/posts/image-links/"},{"categories":["fsdf"],"content":"safkasjf asjfkasjf ","date":"2017-07-15","objectID":"/posts/image-links/:2:0","tags":["image"],"title":"Image links","uri":"/posts/image-links/"},{"categories":["fsdf"],"content":"asfjlsakf asfsajf ","date":"2017-07-15","objectID":"/posts/image-links/:3:0","tags":["image"],"title":"Image links","uri":"/posts/image-links/"},{"categories":["fsdf"],"content":"asf ","date":"2017-07-15","objectID":"/posts/image-links/:4:0","tags":["image"],"title":"Image links","uri":"/posts/image-links/"},{"categories":null,"content":"Export this first post only by bringing point here and doing M-x org-hugo-export-wim-to-md. dsaf ","date":"2017-07-12","objectID":"/posts/post-1/:0:0","tags":null,"title":"Post 4","uri":"/posts/post-1/"},{"categories":null,"content":" Be the root directory for this Hugo site (the directory containing config.toml). test Run hugo server --port 1111 See the site served on “http://localhost:1111/”. ","date":"2017-07-12","objectID":"/posts/prep/:0:0","tags":null,"title":"Preparation","uri":"/posts/prep/"}]